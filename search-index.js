var searchIndex = {};
searchIndex['plumbum'] = {"items":[[0,"","plumbum","*Plumbum* (latin for lead) is a port of Michael Snoyman's excellent\n[`conduit`](https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview)\nlibrary.",null,null],[3,"Kleisli","","The Kleisli arrow from `A` to `ConduitM<I, O, B>`.",null,null],[4,"Chunk","","",null,null],[13,"Chunk","","",0,null],[13,"Flush","","",0,null],[13,"End","","",0,null],[4,"Void","","",null,null],[4,"ConduitM","","Represents a conduit, i.e. a sequence of await/yield actions.",null,null],[13,"Pure","","The case `Pure(a)` means that the conduit contains no further actions and just returns the result `a`.",1,null],[13,"Defer","","The case `Defer(k)` means that the conduit needs another iteration to make progress,\nand the remaining (suspended) program is given by the kleisli arrow `k`",1,null],[13,"Flush","","The case `Flush(k)` means that the conduit instructs the downstream to flush,\nand the remaining (suspended) program is given by the kleisli arrow `k`",1,null],[13,"Await","","The case `Await(k)` means that the conduit waits for a value of type `I`,\nand the remaining (suspended) program is given by the kleisli arrow `k`.",1,null],[13,"Yield","","The case `Yield(o, k)` means that the conduit yields a value of type `O`,\nand the remaining (suspended) program is given by the kleisli arrow `k`.",1,null],[13,"Leftover","","The case `Leftover(i, k)` means that the conduit has a leftover value of type `I`,\nand the remaining (suspended) program is given by the kleisli arrow `k`.",1,null],[5,"consume_chunk","","Wait for a single input value from upstream.",null,{"inputs":[],"output":{"name":"conduitm"}}],[5,"consume","","Wait for an input chunk from upstream.",null,{"inputs":[],"output":{"name":"conduitm"}}],[5,"produce_chunk","","Send a chunk of values downstream to the next component to consume.",null,{"inputs":[{"name":"vec"}],"output":{"name":"conduitm"}}],[5,"produce","","Send a value downstream to the next component to consume.",null,{"inputs":[{"name":"o"}],"output":{"name":"conduitm"}}],[5,"defer","","Defers a conduit action. Can be used to introduce artifical laziness.",null,{"inputs":[],"output":{"name":"conduitm"}}],[5,"leftover_chunk","","Provide a single piece of leftover input to be consumed by the\nnext component in the current binding.",null,{"inputs":[{"name":"vec"}],"output":{"name":"conduitm"}}],[5,"leftover","","Provide a single piece of leftover input to be consumed by the\nnext component in the current binding.",null,{"inputs":[{"name":"i"}],"output":{"name":"conduitm"}}],[11,"map","","",0,{"inputs":[{"name":"chunk"},{"name":"f"}],"output":{"name":"chunk"}}],[11,"unwrap_or","","",0,{"inputs":[{"name":"chunk"},{"name":"o"}],"output":{"name":"o"}}],[11,"from","","",0,{"inputs":[{"name":"chunk"},{"name":"o"}],"output":{"name":"chunk"}}],[0,"io","","Interfacing with `std::io`.",null,null],[5,"reader","plumbum::io","A conduit that produces bytes it reads from the given `Read`.",null,{"inputs":[{"name":"r"},{"name":"usize"}],"output":{"name":"conduitm"}}],[5,"writer","","A conduit that consumes bytes and writes them to the given `Write`.",null,{"inputs":[{"name":"w"}],"output":{"name":"conduitm"}}],[5,"receiver","","A conduit that produces values it receives from the given `Receiver`.",null,{"inputs":[{"name":"receiver"}],"output":{"name":"source"}}],[5,"sender","","A conduit that consumes values and writes them to the given `Sender`.",null,{"inputs":[{"name":"sender"}],"output":{"name":"sink"}}],[5,"sync_sender","","A conduit that consumes values and writes them to the given `SyncSender`.",null,{"inputs":[{"name":"syncsender"}],"output":{"name":"sink"}}],[11,"new","plumbum","Creates the identity arrow.",2,{"inputs":[{"name":"kleisli"}],"output":{"name":"kleisli"}}],[11,"from","","Wraps the given function into an arrow.",2,{"inputs":[{"name":"kleisli"},{"name":"f"}],"output":{"name":"kleisli"}}],[11,"append","","Appends the given function to the tail of the arrow.\nThis corresponds to closure composition at the codomain (post-composition).",2,{"inputs":[{"name":"kleisli"},{"name":"f"}],"output":{"name":"kleisli"}}],[11,"run","","Given an input, runs the arrow to completion and return\nthe resulting program.",2,{"inputs":[{"name":"kleisli"},{"name":"a"}],"output":{"name":"conduitm"}}],[6,"Source","","Provides a stream of output values,\nwithout consuming any input or producing a final result.",null,null],[6,"Conduit","","Consumes a stream of input values and produces a stream of output values,\nwithout producing a final result.",null,null],[6,"Sink","","Consumes a stream of input values and produces a final result,\nwithout producing any output.",null,null],[11,"to_producer","","Generalize a `Source` by universally quantifying the input type.",1,{"inputs":[{"name":"conduitm"}],"output":{"name":"conduitm"}}],[11,"connect","","Pulls data from the source and pushes it into the sink.",1,{"inputs":[{"name":"conduitm"},{"name":"sink"}],"output":{"name":"a"}}],[11,"fuse","","Combines two conduits together into a new conduit.",1,{"inputs":[{"name":"conduitm"},{"name":"conduitm"}],"output":{"name":"conduitm"}}],[11,"transform","","Apply a transformation to all values in a stream.",1,{"inputs":[{"name":"conduitm"},{"name":"f"}],"output":{"name":"self"}}],[11,"extend","","",1,{"inputs":[{"name":"conduitm"},{"name":"t"}],"output":null}],[11,"from_iter","","",1,{"inputs":[{"name":"conduitm"},{"name":"t"}],"output":{"name":"self"}}],[11,"to_consumer","","Generalize a `Sink` by universally quantifying the output type.",1,{"inputs":[{"name":"conduitm"}],"output":{"name":"conduitm"}}],[11,"fold","","Fold all values from upstream into a final value.",1,{"inputs":[{"name":"conduitm"},{"name":"a"},{"name":"f"}],"output":{"name":"self"}}],[11,"and_then","","Appends a continuation to a conduit. Which means,\ngiven a function from `A` to `ConduitM<I, O, B>`,\npasses the return value of the conduit to the function,\nand returns the resulting program.",1,{"inputs":[{"name":"conduitm"},{"name":"f"}],"output":{"name":"conduitm"}}],[11,"and","","Appends two conduits together, which means, it returns a new conduit that\nexecutes both conduits sequentially, and forwards the return value\nof the second.",1,{"inputs":[{"name":"conduitm"},{"name":"conduitm"}],"output":{"name":"conduitm"}}],[11,"zip","","Zips two conduits together, which means, it returns a new conduit that\nexecutes both conduits sequentially, and forwards both return values.",1,{"inputs":[{"name":"conduitm"},{"name":"conduitm"}],"output":{"name":"conduitm"}}],[11,"map","","Modifies the return value of the conduit.\nSeen differently, it lifts a function from\n`A` to `B` into a function from `ConduitM<I, O, A>`\nto `ConduitM<I, O, B>`.",1,{"inputs":[{"name":"conduitm"},{"name":"f"}],"output":{"name":"conduitm"}}],[11,"eq","","",1,{"inputs":[{"name":"conduitm"},{"name":"conduitm"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"conduitm"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"conduitm"},{"name":"a"}],"output":{"name":"conduitm"}}],[14,"pipe!","","Provides a convient syntax for conduit operations.",null,null],[14,"fuse!","","Provides a convient syntax for fusing conduits.",null,null]],"paths":[[4,"Chunk"],[4,"ConduitM"],[3,"Kleisli"]]};
initSearch(searchIndex);
